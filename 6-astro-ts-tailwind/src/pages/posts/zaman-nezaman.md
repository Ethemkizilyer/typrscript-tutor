---
layout: "../../layouts/BlogPost.astro" # layout: "..." aralar캼ndaki bo륿uk dahi 칬nemli hata veriyor.
title: Bu Benim 칖칞칲nc칲 Payla캼m캼m
tags: ["RTK-Query","Fikir"]
date: 2022-12-24

---

RTK Sorgusu En 캻yi Uygulamalar캼 TLDR; Bu g칬nderide, yeni uygulamalar캼m캼zda RTK Sorgusunu kullanmaya ba륿ad캼캼m캼zdan beri grubumdaki di른r geli릆iricilerin g칲ndeme getirdi를 ana sorular캼 ve endi른leri ele alaca캼m. Haziran 2021'de Redux Toolkit, RTK Sorgusu ad캼 verilen g칲칞l칲 bir veri alma ve 칬nbelle른 alma arac캼n캼 kullan캼ma sundu. React-Query gibi pop칲ler alternatiflerle kar캼la릆캼r캼ld캼캼nda, RTK Query'nin ana g칲c칲, redux ma르zas캼yla varsay캼lan entegrasyonudur. Di른r indirgeyiciler, par칞alar ve hatta Redux DevTools taraf캼ndan yakalanabilecek eylemler 칲retir ki bu 칞ok uygundur. RTK Sorgusu - RTK Sorgulaman캼n sorumlulu릇 nedir? 游뱂 RTK Sorgusu 릇nlardan sorumludur: 캻stemci taraf캼nda veri alma ve 칬nbelle른 al캼nm캼 verileri tutma. Verileri de를릆irme (olu릆urma/g칲ncelleme/silme) ve sunucudaki de를를klikleri 칬nbellekle e를tleme. 캻steklerin ya르m d칬ng칲s칲n칲 takip etmek (칬rn. isLoading, isError). Ayn캼 veriler i칞in yinelenen isteklerden ka칞캼n캼rken 칬nbelle른 al캼nm캼 verileri sunar. Gerekti를nde verileri yeniden getirme (ve 칬nbellekle e를tleme). - HER istek i칞in RTK Sorgusu kullanmal캼 m캼y캼z? 游뱂 캻deal olarak, evet. Uygulaman캼n ihtiya칞 duydu릇 a칞캼ktaki API u칞 noktalar캼n캼 sorgulamak/de를릆irmek i칞in API nesnesini (RTK Sorgusu createApi'yi d캼르 aktar캼r) kullanmal캼y캼z. RTKQ'nun en iyi 른kilde 칞al캼릀as캼 i칞in uygulama ba캼na bir API dilimi olmal캼d캼r. Daha fazla bilgi i칞in 릇na bak캼n: Bir API dilimini tan캼mlama. Bundan tam olarak yararlanmak i칞in, t칲m istekler i칞in RTKQ kullanabiliriz ve kullanmal캼y캼z. Dorudan UI bile른nlerine hizmet etmeyen istekler i칞in bile (React kancalar캼 arac캼l캼캼yla). Daha fazla bilgi i칞in 릇na bak캼n: React Hooks Olmadan Kullan캼m. - Hala eski g칲zel redux ma르zas캼n캼 kullanmal캼 m캼y캼z? 游뱂 createApi'nin, RTK'n캼n createSlice (kendi i칞inde createReducer+createAction'캼 soyutlayan) 칲zerindeki bir soyutlama d칲zeyi oldu릇nu bilmek 칬nemlidir. Halihaz캼rda ba륾a indirgeyicilere sahip olabilecek bir redux deposuna eklemek i칞in ba륾a bir indirgeyici olu릆urur. RTKQ'dan (createApi olmayan indirgeyiciler) tamamen yararlanan uygulamalarda h칙l칙 d칲zenli indirgeyiciler olabilir. Sunucu verileri olmayan herhangi bir genel durumu i륿eyebilirler. 칐rne를n, filtre durumu, arama terimi, ge칞i durumu, sayfaland캼rma durumu vb. 캻stemcide 칬nbelle른 al캼nan herhangi bir sunucu verisi i칞in, yaln캼zca RTKQ'nun API dilim azalt캼c캼s캼n캼 kullanmal캼 ve sunucu verilerini ba륾a bir yerde tutmaktan ka칞캼nmal캼y캼z (aksi takdirde, g칲ncellemeler/mutasyonlar durumunda durumunu manuel olarak senkronize etmemiz gerekir). Normal indirgeyicilerle birlikte RTKQ API d칲칲r칲c칲ye sahip bir redux ma르zas캼 - Birden fazla API 칞ar캼s캼n캼n karma캼k mant캼캼na ne dersiniz? 游뱂 칂o릇 durumda, bir iste를n ard캼ndan di른rini veya birden 칞ok iste를 paralel olarak y칲r칲tmemiz gerekir. Her iki durumda da, ilk iste를n u칞 noktas캼 i칞in iste른 ba륿캼 bir parametre olan RTKQ'nun onQueryStarted parametresini kullanmal캼y캼z. Bize iste를n orijinal s칬z nesnesine ( queryFulfilled) eri를m sa륿ar ve onu bekleyebilir veya di른r vaatlerle birlikte Promise.all'캼 kullanabiliriz. Sunucuya birden fazla 칞ar캼 g칬nderen karma캼k bir istek - H칙l칙 zaman uyumsuz i륿emlere ihtiyac캼m캼z var m캼 (칬r. thunk'lar)? 游뱂 RTKQ ile ilgili deneyimime g칬re, onQueryStarted 칞ok kullan캼륿캼d캼r ve uygulamadaki redux zaman uyumsuz ara katman yaz캼l캼m캼n캼n 칞o릇nun yerini alabilir. (칬r. redux-thunk, redux-saga, redux-mant캼k). Bununla birlikte, mant캼캼m캼z캼n tek bir u칞 noktaya ba륿캼 olmas캼n캼 ve daha genel olmas캼n캼 istemiyorsak (칬rne를n, baz캼 isteklerle bir sayfay캼 칬ny칲klemek) yine de zaman uyumsuz bir eyleme ihtiyac캼m캼z olabilir. Gerekli g칬r칲n칲yorsa, onQueryStarted mant캼klar캼yla birlikte zaman uyumsuz eylemleri kullanmakta sorun yoktur (RTK'n캼n createAsyncThunk'a bak캼n). - Veriler nas캼l yeniden getirilir / 칬nbellek nas캼l d칲zg칲n 른kilde ge칞ersiz k캼l캼n캼r? 游뱂 RTKQ ile verileri yenilemenin ana y칬ntemi 칐nbellek Etiketleri kullanmakt캼r. Hem sorgu u칞 noktalar캼na hem de mutasyon u칞 noktalar캼na (칬r. GET /users ve POST /users) sahip kaynaklarla ura캼rken en 칞ok yard캼mc캼 olur. Sorgu u칞 noktas캼na bir etiket sa륿ayabiliriz (basit bir dize etiketi veya daha karma캼k bir nesne etiketi) ve bu sorgu u칞 noktas캼ndaki t칲m kaynaklar etiketi al캼r. Bu etiketi ge칞ersiz k캼lmak i칞in tan캼mlanan bir mutasyon u칞 noktas캼n캼 칞a캼rd캼캼m캼zda, bu etikete sahip t칲m sorgu u칞 noktalar캼 otomatik olarak 칬nbelle를 (depo) yeniden getirecek ve g칲ncelleyecektir. 칐nbellek etiketlerine ek olarak, 칬nbelle를 ge칞ersiz k캼lmak i칞in daha fazla y칬ntem vard캼r (farkl캼 kullan캼m durumlar캼 i칞in). K캼sacas캼: refetch : Sorgu kancalar캼 taraf캼ndan d칬nd칲r칲len bir i륿ev. Bir yeniden getirmeyi tetikler (genellikle useEffect i칞inde 칞ar캼l캼r). inisiye : Biti noktas캼 nesnesindeki bir i륿ev. Yeniden getirmeyi tetikler. keepUnusedDataFor : Abone olmadan (onu kullanan i륿enmi bile른nler olmadan) verilerin tutulaca캼 s칲re (saniye). Varsay캼lan de른r 60't캼r. refetchOnMountOrArgChange : Yeni bile른nler abone oldu릇nda veya farkl캼 ba캼ms캼z de를륾enlerle bir kanca 칞ar캼ld캼캼nda daha s캼k yeniden getirir. refetchOnFocus : Pencere oda캼nda veya sekme anahtar캼nda yeniden getir. refetchOnReconnect : 캻nternet ba륿ant캼s캼 yeniden kurulursa yeniden getirir. updateQueryData : Etiketlerle otomatik g칲ncellemelerin yeterli olmad캼캼 durumlarda (칬r. yan캼t gelmeden 칬nce g칲ncelleme) bir u칞 nokta i칞in 칬nbellek de른rini manuel olarak g칲ncellemenin daha geli릀i bir yolu. Bunlar hakk캼nda daha fazla bilgi burada bulunabilir. - Hatalar nas캼l d칲zg칲n bir 른kilde ele al캼n캼r? 游뱂 Hata nesnesini alma 른klimiz, varsay캼lan fetchBaseQuery'yi (hata adl캼 bir 칬zelli를 d칬nd칲r칲r) veya 칬zel bir getirme sorgusu (hatan캼n nas캼l d칬nd칲r칲lece를ne karar verebilece를miz) kullan캼p kullanmad캼캼m캼za ba륿캼d캼r. Belirli bir u칞 noktadaki bir hata i칞in 칬zel bir i륿eme ihtiya칞 duymam캼z durumunda, bunu queryFulfilled taahh칲d칲nde hatay캼 yakalayarak onQueryStarted ile yapabiliriz: onQueryStarted i칞indeki s칬z hatas캼n캼 yakalamak - RTKQ'nun 칬nbelle른 al캼nm캼 verilerini kullanan se칞iciler nas캼l olu릆urulur? 游뱂 Her u칞 nokta, depodan 칬nbelle른 al캼nm캼 verileri i칞in bir se칞ici d칬nd칲ren bir se칞me i륿evi sa륿ar (bu se칞ici, sorgu kancalar캼 olarak adland캼raca캼m캼z ba캼ms캼z de를륾en olarak bir 칬nbellek anahtar캼 alabilir). Bunun gibi basit bir se칞ici olu릆urabiliriz: 칬nbelle른 al캼nm캼 verilere hizmet veren bir se칞ici olu릆urma 칐rnekle ilgili not: ayn캼 u칞 nokta i칞in birden 칞ok se칞iciye ihtiya칞 duyabilece를miz durumlarda, api.endpoints.getUsers.select() 칬른sini ayr캼 ayr캼 칞a캼rmak ve onu kullanan birden 칞ok se칞ici olu릆urmak en iyisi olacakt캼r. Bu, birle를k se칞iciler veya verileri hesaplayan se칞iciler olu릆urmak i칞in de yararl캼 olabilir (칬rn. yeniden yans캼tma ile). - "Aptal" bile른nlerde kanca spam'캼 nas캼l 칬nlenir? 游뱂 RTKQ'nun bile른nlerin jenerik/aptal/sunumsal olmas캼n캼 engellemeye yard캼mc캼 olmad캼캼 dorudur. Tonlarca React kancas캼 sa륿ayarak bizi daha fazla bile른ni dorudan ma르zaya ba륿amaya itiyor. Ancak bu sorunun RTKQ'nun kendisiyle hi칞bir ilgisi yoktur. Bence ma르zaya daha fazla bile른n ba륿amak k칬t칲 bir uygulama de를l ve ayn캼 zamanda performans캼 da art캼r캼yor. Bu, g칲n칲m칲zde kancalar 칞a캼nda bir칞ok React+Redux uygulamas캼n캼n ilerledi를 y칬nd칲r ve RTKQ bu yakla캼m캼 benimser. Bu konu hakk캼nda daha fazla bilgiyi buradan okuyabilirsiniz. Kendimizi tek bir bile른nde (birden 칞ok t칲rde veri/mutasyon kullanan) 칞ok say캼da kanca kullan캼rken ne kadar 칞abuk buldu릇muzla ilgileniyorsan캼z, t칲m kanca 칞ar캼lar캼n캼 kolayca ayr캼 bir 칬zel kancaya 칞캼karabilirsiniz.